%include forall.fmt

%if style == newcode

%format ^ = " "
%format ^^ = " "
%format lett = "let"

%else

%format (pair (a) (b)) = "\langle" a , b "\rangle"

%format param = "\text{\textendash}"

%subst dummy = "\text{\textendash}"

% If an argument to a formatting directive starts with let, lhs2TeX likes to
% helpfully prepend a space to the let, even though that's seldom desirable.
% Write lett to prevent that.

%format lett = "\mathbf{let}"

%format alpha = "\alpha"
%format Nat = "\mathbb{N}"
%format Int = "\mathbb{Z}"

%format `times` = "\times"
%format Gamma = "\Gamma"
%format Gamma' = "\Gamma\myquote"
%format Gamma1
%format Gamma2
%format `preceq` = "\preceq"
%format v1
%format v2
%format v3
%format v4

%format V1
%format V2

%format e1
%format e2
%format e3
%format de1
%format de2

%format t1
%format t2

%format grand_total2
%format dgrand_total2

%format `oplus` = "\oplus "
%format `ominus` = "\ominus "
%format oplus = "(\oplus)"
%format ominus = "(\ominus)"
%format nilc = "\NilC{}"
%format (nil(v)) = "\NilC{" v "}"
%format NIL = "\NILC"
%format `ocompose` = "\circledcirc "
%format ocompose (dv1) (dv2) = dv1 "\circledcirc" dv2

%format (oplusIdx(t)) = "\oplus_{" t "}"
%format (ominusIdx(t)) = "\ominus_{" t "}"
%format (nilIdx(t)) = "\NilC{" t "}"
%format (ocomposeIdx(t)) = "\circledcirc_{" t "}"
%format (doeIdx(v)) = "\Doe_{" v "}"

%format `doe` = "\Doe"
%format chs (v) = "\ChangeStruct{" v "}"
%format bchs(v) = "\widetilde{" v "}"

%format `eqdef` = "\eqdef"
%format `such` = "\mid"
%format `union` = "\cup"

%format ^ = " "
%format ^^ = "\;"
%format ^^^ = "\\"
%format ^&^ = "&"

%format f0
%format f1
%format f2
%format f3
%format f1' = "f_{1}\myquote"

%format tf1
%format tf2
%format dtf1
%format dtf2

%format a0
%format a1
%format a2
%format a3

%format b1
%format b2
%format b3

%format p1
%format p2

%format c1
%format c2

%format da0
%format da1
%format da2
%format db0
%format db1
%format db2

%format g1
%format g2
%format g3

%format dg1
%format dg2

%format dv0
%format dv1
%format dv2
%format dv3

%format dfa = df "_a"
%format dfb = df "_b"
%format dsa = ds "_a"
%format dsb = ds "_b"
%format dta = dt "_a"
%format dtb = dt "_b"
%format dva = dv "_a"
%format dvb = dv "_b"
%format va1
%format va2
%format vb1
%format vb2

%format dt1
%format dt2

%format x0
%format x1
%format x2
%format x3
%format xn = "x_n"

%format as1
%format as2
%format xs1
%format xs2
%format ys1
%format ys2
%format output1
%format output2

%format u1
%format u2

%format df0
%format df1
%format df2
%format df3

%format dx0
%format dx1
%format dx2
%format dx3

%format : = ":\,"
%format Dt = "\Delta"
%format DtIdx(t) = "\Delta_{" t "}"
%format Dt2 = "\Delta_2"
%format DV = "\Delta V"

%format Sigma = "\Sigma"
%format eval(t) = "\Eval{" t "}"
%format evalInc(t) = "\EvalInc{" t "}"
%format (evalConst(c)) = "\EvalConst{" c "}"
%format (derive(t)) = "\Derive{" t "}"
%format (deriveConst(t)) = "\DeriveConst{" t "}"

%format `cong` = "\cong"
%format `congDt` = "\mathrel{\cong_\Delta}"

%format nabla = "\nabla"
%format emptyCtx = "\EmptyContext"
%format emptyRho = "\EmptyEnv"
%format rho = "\rho"
%format drho = "\D\rho"
%format drhoa = drho "_a"
%format drhob = drho "_b"
%format rho1
%format rho2
%format sigma = "\sigma"
%format tau = "\tau"
%format sigma1
%format sigma2
%format tau1
%format tau2
%format iota = "\iota"

% Hook into forall.fmt:

%format exists(x) = exists_ x "\hsforall "
%format exists_ = "\exists "

%format fromto (tau) (v1) (dv) (v2) = "\validfromto{" tau "}{" v1 "}{" dv "}{" v2 "}"
%format fromtosem (gamma) (tau) (v1) (dv) (v2) = "\validfromto{" gamma, tau "}{" v1 "}{" dv "}{" v2 "}"
%format fromtosyn (gamma) (tau) (v1) (dv) (v2) = "\validfromtosyn{" gamma "}{" tau "}{" v1 "}{" dv "}{" v2 "}"
%format fromtosynuntyped (gamma) (v1) (dv) (v2) = "\validfromtosynunt{" gamma "}{" v1 "}{" dv "}{" v2 "}"


%format validV (tau) = "\mathcal{V}_{" tau "}"
%format valid (tau) (v) (dv) = "(" v " , " dv ") \in V_{" tau "}"

%format (new(v)) = "\New{" v "}"
%format (old(v)) = "\Old{" v "}"
%format `betaeq` = "=_{\beta}"
%format `eq` = "="

%format == = "\equiv"
%format /- = "\vdash"

%format `and` = "\land"

%format => = "\Rightarrow"
%format _ = "\text{\textunderscore}"
%format =>_ = "\mathord{\Rightarrow}\text{\textunderscore}"
%format mutual = "\textbf{mutual}"
%format ... = "\ldots"

%format Theta(n) = "\Theta(" n ")"
%format o(n) = "o(" n ")"

%format cache1
%format cache2
%format caches1
%format caches2
%format mapCache1
%format mapCache2
%format cx1
%format cx2

%format size(s) = "\left|{" s "}\right|"

%format succ = "\mathbf{succ}"
%format add = "\mathbf{add}"

%format `stoup` = "\filleddiamond"
%  format `stoup` = "\blackdiamond"

%format n1
%format n2
%format dn1
%format dn2

%format w1
%format w2
%format dw1
%format dw2
%format rho' = rho "\myquote"
%format drho' = drho "\myquote"

% indexed big-step eval
%format ibseval (t) rho (n) (v) = rho "\vdash" t "\Downarrow_{" n "}" v
% without environments
%format ibseval' (t) (n) (v) = t "\Downarrow_{" n "}" v
% big-step eval
%format bseval  (t)  rho (v) = rho "\vdash" t "\Downarrow" v
% change big-step eval
%format dbseval (dt) rho drho (dv) = rho `stoup` drho "\vdash" dt "\Downarrow_{\Delta}" dv

%format vn = "v_n"
%format dvn = dv "_n"
%format dxn = dx "_n"

%format (star rho (t)) = rho "^*(" t ")"
%format starv v = v "^*"

%format /-- = "\vdash_{\Delta}"
%format `vdashConst` = "\vdash_{\CONST}"
%format `vdashPrim` = "\vdash_{\mathcal{P}}"

%format evalVal (w) rho = "\mathcal{V}\left\llbracket" w "\right\rrbracket" rho
%format evalPrim p v = "\mathcal{P}\left\llbracket" p "\right\rrbracket" v

%format devalVal (w) rho = "\mathcal{V}_{\Delta}\left\llbracket" w "\right\rrbracket" rho
%format devalPrim p v = "\mathcal{P}_{\Delta}\left\llbracket" p "\right\rrbracket" v

%format (valset (tau)) = "\mathcal{RV}\left\llbracket" tau "\right\rrbracket"
%format (compset (tau)) = "\mathcal{RC}\left\llbracket" tau "\right\rrbracket"
%format (envset (gamma)) = "\mathcal{RG}\left\llbracket" gamma "\right\rrbracket"

%format valsetunt = "\mathcal{RV}"
%format compsetunt = "\mathcal{RC}"

%format ilcTau = "\ilcTau"
%format ilcUntau = "\ilcUntau"
%format dilcTau = "\dilcTau"
%format dilcUntau = "\dilcUntau"

%endif

\def\deriveDefCore{%
\begin{align*}
  |derive(\(x : sigma) -> t)| &= |\(x : sigma) (dx : Dt^sigma) -> derive(t)| \\
  |derive(s t)| &= |derive(s) t (derive(t))| \\
  |derive(x)| &= |dx| \\
  |derive(c)| &= |deriveConst(c)|
\end{align*}
}

%if false
% derive(lett x = t1 in t2) =
%   lett  x = t1
%         dx = derive(t1)
%         in   derive(t2)
% \begin{code}
% derive(\(x : sigma) -> t))  = \(x : sigma) (dx : Dt^sigma) -> derive(t)
% derive(s t)                 = derive(s) t (derive(t))
% derive(x)                   = dx
% derive(c)                   = deriveConst(c)
% \end{code}
%endif
