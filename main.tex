% Ensure that arXiv processes this as PDF.
\pdfoutput=1

\documentclass{book}
\usepackage{natbib}
\usepackage{comment}
\bibliographystyle{abbrvnat}
\input{packages}
\input{macros}

\usepackage{amsthm,fixfoot}

\usepackage{listings}
\input{lstsetup}

\input{aosd13/customMacros}
\input{pldi14/customMacros}

\input{pldi14/macros_part2}
% from pldi14
\newcommand{\ILC}{ILC}
% from aosd13
\usepackage{comment}
\excludecomment{extraEval}
\includecomment{techrep}
\excludecomment{nontechrep}
\excludecomment{todos}
\includecomment{forNonBeamer}

\title{PhD Thesis}
\author{Paolo G. Giarrusso}
\begin{document}
\maketitle
\chapter{Intro}

A program manipulating collections of data will often perform queries on those
collections. These collections can be big, so query execution can be expensive
and warrant considerable optimization effort.
% \section{}
Efficient queries are written either as declarative database queries that are
optimized by database optimizers, or as manually optimized programs using
collection libraries. Compare maintaining anagraphic data for a population
as either a relational database or a collection:
\begin{itemize}
\item If the population data is maintained as a database, a programmer that needs to
  look up quickly people by age, can just add an index and keep the lookup query
  unchanged; the index can then be automatically maintained.
\item If the population data is maintained as an in-memory collection, adding an
  index requires modifying by hand queries to reuse it for maximum performance,
  and ensuring all changes to population data update the index to maintain
  correctness. This is error-prone and violations are common \pg{XXX}, even if
  there is quite some research on the problem.
\end{itemize}
Modern libraries offer high-level APIs for manipulating (in-memory) collections;
equivalently, such an API is an embedded domain-specific language (EDSL).
Compared to SQL, an EDSL will typically have first-class support for using
arbitrary user-defined functions in queries, because it will allow .

\pg{Examples!}

Collection operations are typically executed directly; however, they can instead
construct a query representation that can then be optimized.

To optimize queries we can transfer techniques known from both databases and
programming languages. Incrementalizing arbitrary queries, however, is a much
harder problem in general.

\section{Our design for incrementalizing queries}
We designed our incrementalization system by abstracting from needs and ideas for
collection APIs.
\begin{itemize}
\item collection APIs are typically higher-order. This allows further
  flexibility compared to first-order query languages: in particular we can
  design new operators in terms of existing ones.
\item many collection types support equations that can be used for optimization.
  For instance
\end{itemize}

\subsection{Domain-specific}
Special optimizations are possible because many collection datatypes, equality
is not purely structural. Two lists are equal if they are structurally equal.
But two sets are equal if they have the same elements, which does not imply they
are structurally equal.\footnote{\pg{Cool but not necessarily appropriate here.}
  Technically, the datatypes are not freely generated and their signatures
  contain further equations.}
%
A general-purpose optimizer cannot exploit this to return a structurally
different set with ``the same meaning'', but a domain-specific optimizer can be
instructed to do so.

Taking this into account we were led to design our incrementalization system to
allow domain-specific support from the start.

\chapter{Reifying collection queries}

\input{aosd13/graphs/evalResLos}
\input{aosd13/paperBody}
\input{aosd13/aosd13-extended-appendixes}

\newcommand{\co}[1]{\code{#1}} %Adaptation between different interfaces
\chapter{Incrementalizing simply-typed \TitleLambda{}-calculus}
\input{pldi14/agda}

\input{pldi14/sec-intro}
\input{pldi14/sec-change-theory}
\input{pldi14/sec-differentiate}
\input{pldi14/sec-practice}
\input{pldi14/sec-rw}
\input{pldi14/sec-concl}

% Appendixes
\input{pldi14/sec-evaluation}
\input{pldi14/sec-addendum}

\input{pldi14/sec-formal}

\input{pldi14/sec-change-structures}

\begin{oldSec}
\input{pldi14/sec-STLC-correct}
\end{oldSec}

\begin{oldSec}
\input{pldi14/sec-informal}
\end{oldSec}


\pg{Plan for things that complete the original paper's story: add them by
  revising that text and in that chapter.}

\bibliography{Bibs/DB,Bibs/ProgLang,Bibs/SoftEng,Bibs/own}
\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
