\begin{otherlanguage}{ngerman}

\chapter{Zusammenfassung}
\pagestyle{empty}
\thispagestyle{empty}

In modernen, universellen Programmiersprachen sind Abfragen auf
Speicher-basierten Kollektionen oft rechenintensiver als erforderlich. Während
Datenbankenabfragen vergleichsweise einfach optimiert werden können, fällt dies bei
Speicher-basierten Kollektionen oft schwer, denn universelle
Programmiersprachen sind in aller Regel ausdrucksstärker als
Datenbanken. Insbesondere unterstützen diese Sprachen meistens
verschachtelte, rekursive Datentypen und Funktionen höherer Ordnung.

Kollektionsabfragen können per Hand optimiert und inkrementalisiert
werden, jedoch verringert dies häufig die Modularität und ist oft zu
fehleranfällig, um realisierbar zu sein oder um Instandhaltung von
entstandene Programm zu gewährleisten.
Die vorliegende Doktorarbeit demonstriert, wie Abfragen auf Kollektionen
systematisch und automatisch optimiert und inkrementalisiert werden
können, um Programmierer von dieser Last zu befreien.
%
Die so erzeugten Programme werden in derselben Kernsprache ausgedrückt,
um weitere Standardoptimierungen zu ermöglichen.

Teil~\ref{part:ch-aosd13} entwickelt eine Variante der Scala API für
Kollektionen, die \emph{Staging} verwendet um Abfragen als abstrakte
Syntaxbäume zu \emph{reifizieren}.
Auf Basis dieser Schnittstelle werden anschließend domänenspezifische
Optimierungen von Programmiersprachen und Datenbanken angewandt; unter
anderem werden Abfragen umgeschrieben, um vom Programmierer ausgewählte
Indizes zu benutzen. Dank dieser Indizes kann eine erhebliche
Beschleunigung der Ausführungsgeschwindigkeit gezeigt werden; eine
experimentelle Auswertung zeigt hierbei Beschleunigungen von
durchschnittlich 12x bis zu einem Maximum von 12800x.

Um Programme mit Funktionen höherer Ordnung durch
Programmtransformation zu inkrementalisieren, wird in Teil~\ref{part:incr} eine
Erweiterung der \emph{Finite-Differenzen-Methode} vorgestellt
\citep{Paige82FDC,Blakeley:1986:EUM,Gupta99MMV} und ein erster
Ansatz zur Inkrementalisierung durch Programmtransformation für Programme mit
Funktionen höherer Ordnung entwickelt.
%
% "Eingangsprogramme": Orig. "base program"
%
Dabei werden Programme zu \emph{Ableitungen}
transformiert, d.h. zu Programmen die \emph{Eingangsdifferenzen} in
\emph{Ausgangdifferenzen} umwandeln.
Weiterhin werden in den Kapiteln~\ref{ch:derive-formally}--\ref{ch:change-theory} die Korrektheit des
Inkrementalisierungsansatzes für einfach-getypten und ungetypten
λ-Kalkül bewiesen und Erweiterungen zu System~F besprochen.

Ableitungen müssen oft Ergebnisse der ursprünglichen Programme wiederverwenden. Um
eine solche Wiederverwendung zu ermöglichen, erweitert Kapitel~\ref{ch:cts} die
Arbeit von \citet{Liu95} zu Programmen mit Funktionen höherer Ordnung und
entwickeln eine Programmtransformation solcher Programme im \emph{Cache-Transfer-Stil}.

Für eine effiziente Inkrementalisierung ist es weiterhin notwendig, passende
Grundoperationen auszuwählen und manuell zu inkrementalisieren. Diese
Arbeit deckt einen Großteil der wichtigsten Grundoperationen auf
Kollektionen ab. Die Durchführung von Fallstudien zeigt deutliche
Laufzeitverbesserungen sowohl in Praxis als auch in der asymptotischen
Komplexität.

% Ensure the empty pagestyle applies to the last page.
\clearpage
\end{otherlanguage}

% Local Variables:
% ispell-local-dictionary: german
% End:
