% Thanks to \frontmatter, this is unnumbered.
% https://tex.stackexchange.com/a/244746/1340
\chapter{Abstract}

In modern programming languages, queries on in-memory collections are often more
expensive than needed.
While database queries can be readily optimized, it is often not trivial to use
them to express collection queries which employ nested data and first-class
functions, as enabled by functional programming languages.

Collection queries can be optimized and incrementalized by hand, but this
reduces modularity, and is often too error-prone to be feasible or to enable
maintenance of resulting programs. To free programmers from such burdens,
in this thesis we study how to optimize and incrementalize such collection queries.
Resulting programs are expressed in the same core language, so that they can be
subjected to other standard optimizations.

To enable optimizing collection queries which occur inside programs, we develop a
staged variant of the Scala collection API that \emph{reifies} queries as ASTs.
On top of this interface, we adapt domain-specific optimizations from the fields
of programming languages and databases; among others, we rewrite queries to use
indexes chosen by programmers. Thanks to the use of indexes we show significant
speedups in our experimental evaluation, with an average of 12x and a maximum of
12800x.

To incrementalize higher-order programs by program transformation, we extend
\emph{finite differencing} \citep{Paige82FDC,Blakeley:1986:EUM,Gupta99MMV} and
develop the first approach to incrementalization by program transformation for
higher-order programs. Base programs are transformed to \emph{derivatives},
programs that transform input \emph{changes} to output changes.
We prove that our incrementalization approach is correct: We develop the theory
underlying incrementalization for simply-typed and untyped $\lambda$-calculus, and
discuss extensions to System F\@.

Derivatives often need to reuse results produced by base programs: to enable
such reuse, we extend work by \citet{Liu95} to higher-order programs, and
develop and prove correct a program transformation, converting higher-order
programs to \emph{cache-transfer-style}.

For efficient incrementalization, it is necessary to choose and incrementalize
by hand appropriate primitive operations. We incrementalize a significant subset
of collection operations and perform case studies, showing order-of-magnitude speedups
both in practice and in asymptotic complexity.
% To incrementalize programs efficiently, derivatives
% To use our approach a certain domain, designers must provide
% relies on efficient primitives

% \begin{abstract}
% \end{abstract}