\section{Weakening and strenghtening the definition of change structures}
\pg{Make less drafty; this section comes wholesale from changes.tex.}
An alternative definition of change structures is the following; we will make
some requirements optional, therefore some criteria are redundant. As it will
become clear, this definition can be compared with a \emph{category}, where
values are objects and changes are arrows.
\begin{definition}[Change structure]
A change structure on a set $V$ is given by:
\begin{subdefinition}
\item a set of changes $\GD V$.
\item\label{subdef:src} a function $\Term{src} : \GD V → V$ mapping a change to
  its source value. In our paper, we consider a separate set of changes
  $\Delta v$ for each source $v \in V$. Here, instead, I consider a single set
  with all the changes, and a function mapping them to their source.
\item\label{subdef:dst} A function $\Term{dst} : \GD V → V$ mapping a change to
  its destination value. If two changes share source and destination, we say
  they are \emph{delta-observationally equivalent}, or for short,
  \emph{equivalent}, and we write $\Doe$.
\item\label{subdef:nil} A function $\Term{nil} : V → \GD V$ mapping a value to
  its nil change, such that $\Term{src} \cdot \Term{nil} = \Term{Id}$ and
  $\Term{dst} \cdot \Term{nil} = \Term{Id}$.
\end{subdefinition}
In addition, we can require any of the following properties.
\begin{subdefinition}[resume]
\item\label{subdef:exist} \emph{Completeness}: Between any two values there exists
  at least a change.
\item\label{subdef:ominus} \emph{$\ominus$, the witness of completeness:} A
  function $\ominus : V \times V → \GD V$ mapping two values to one change
  between them, such that $\Term{dst} \cdot \ominus = \pi_2$ and
  $\Term{src} \cdot \ominus = \pi_1$. This requirement implies
  \cref{subdef:exist}, but gives also a function that computes this change.

\item \label{subdef:composition} \emph{change composition}:
  $\odot$ between arrows with matching destination and
  source (this can be defined categorically via pullbacks --- it's the same
  thing as the definition of composition in an internal category). This property
  can always be enforced by a free construction (consider for reference the free
  category constructed over a graph).
\item \label{subdef:groupoid} change inversion $\Term{inv}$, such that
  $\Term{src} \cdot \Term{inv} = \Term{dst}$ and
  $\Term{dst} \cdot \Term{inv} = \Term{src}$. We also write ${dv}^{-1}$ for
  $\Term{inv}\ dv$.
\item \label{subdef:thin} \emph{Thinness}: Between any two values there exist at
  most a change. This property can always be enforced by quotienting changes by
  the equivalence $\Doe$. That is, one can construct $\Delta V / \Doe$ to
  obtain a new change structure that is also thin.
\end{subdefinition}
\end{definition}

\paragraph{Relation to the original definition}
If we include subproperties up to \cref{subdef:ominus}, we have a definition
equivalent to the original one.\footnote{In the original definition, we
  additionally have $\Term{nil}\ v = v \ominus v$, while here we only have an
  equivalence $\Term{nil}\ v \Doe v \ominus v$; one could add the former requirement,
  but I believe it is not important.}
%; our current formalization does not have the former requirement\pg{recheck}.

Conversely, as far as I understand, one can produce the above definition (again,
up to \cref{subdef:ominus}) if one takes the original definition and
formulates it categorically, as we show next.

\pg{Recheck, verify or drop.}
Instead of representing a \emph{family} of change sets $\Delta v$ indexed by
$v \in V$ directly, one can just have a single set of all changes, and use
$\Term{src}$ to map a change $d_v \in \Delta V$ to its base value $v$ belonging
to the index set $V$. I believe that $\Term{src}$ is technically a
fibration\footnote{\url{http://ncatlab.org/nlab/show/fibration\#fibrations_in_category_theory}},
but I am not familiar with the theory of fibration enough to be sure.

To show the equivalence of the two definitions, one can set
$\Delta V = \sum_{v: V} \Delta v$. If the change sets are already disjoint and
one works in set theory, it's not necessary to use disjoint union
($\Sigma$-type) to define $\Delta V$; one can simply use a standard
set-theoretic union $\Delta V = \cup_{v: V} \Delta v$.

Next, we need to express the signature of $\oplus$:
\[\oplus: (v: V) → (dv: \Delta v) → V\]
when we only have $V$ and $\Delta V = \sum_{v: V} \Delta v$; however, if we
curry the signature of $\oplus$ using a $\Sigma$-type, we get
$\sum_{v: V} \Delta v → V$, that is $\Delta V → V$; the resulting function maps
a change to its destination, hence it is nothing but $\Term{dst}$.

\paragraph{Variants of this definition}
Bob Atkey noticed that if one only considers requirements up to
\cref{subdef:nil}, the resulting definition is equivalent to \emph{reflexive
  graphs}, which have been used to construct parametric models of
$\lambda$-calculi. This explains the similarity between both transformations.

If instead we consider all requirements, we get a \emph{complete groupoid} of
changes; however, not all applications require so much structure.

In particular, inverting changes is rather seldom needed.

Moreover, if our change structure is both complete and thin, it becomes harder
to study different constructions of changes, because you can always immediately
construct the change between arbitrary values $v_1$ and $v_2$, instead of having
to compose changes or use other algebraic operations on them.

\subsection{The \emph{pair model}}
A change between values $v_1$ and $v_2$ can be represented by their pair
$(v_1, v_2)$. Hence, we can define the \emph{pair model}, where the set of
changes $\Delta V$ on values $V$ is equal to $V^2$ and other operations are
defined in the obvious way. This set of pairs models a \emph{complete} change
structure on $V$.

As mentioned, the \emph{pair model} is equivalent to some other interesting
ones: $\Delta V = V^2 \cong \sum_v \left(\Delta v / \mathbin{\Doe}\right)$. That is, instead of
considering pairs, we can take another \emph{complete} change structure, defined
as in the paper, form the disjoint union $\sum_v \Delta v$, and quotient it
through $\Doe$ to obtain an isomorphic change structure (or equivalently, we
can also form $\sum_v \left(\Delta v / \mathbin{\Doe}\right)$ and get an isomorphic result, since
changes in different change sets can't be equivalent).

\section{Additional Change Structures}
\label{sec:additional}
In this appendix, we describe informally additional change structures which can be defined.

% XXX elaborate/continue/review notation.

\subsection{Replacement pairs}
In this kind of change structure, %XXX rephrase
the change $\Diff{b}{a}$ is simply represented by $(a, b)$, and
the definition of update is induced by the equation $\Update{a}{\Diff{b}{a}} = b$; we simply set
$\Update{a}{(a, b)} = b$.

Since $\Diff{b}{a}$ also stores $a$, this change structure
supports \emph{change inversion}.

\subsection{Replacement values}
In this kind of change structure, %XXX rephrase
the change $\Diff{b}{a}$ is simply represented by $b$, and
update is defined by the equation $\Update{a}{\Diff{b}{a}} = b$.

We get this kind of change structure by taking replacement pairs
$(a, b)$ and dropping the source value %XXX
$a$, hence also support for change inversion.

\subsection{Change structure for product types}
We can define $\Delta(A \times B) = \Delta{A} \times \Delta{B}$.

To verify that the definition is ``good'', we need to verify that
we can also write derivatives for introduction and elimination
forms. We have verified that this works for the pair constructor,
the two projections, and the eliminator for pairs.

\subsection{Optimizing change structure for product types}
We can also try defining
$\Delta(A \times B) = 1 + \Delta{A} + \Delta{B} + \Delta{A}
\times \Delta{B}$, which allows omitting nil changes.

This definition is interesting because we \emph{can} define the
change structure, but we have issues with its elimination forms.
Take a pair of functions $p = (f, g)$ and its change
$dp = \mathit{inj}_3 db$ (with $db : \Delta b)$. How are we to
compute the derivative of its first projection, $fst' p dp$? This
must be the nil change of $f$, but this has a few issues:
\begin{itemize}
\item such a derivative is not self-maintainable because it
  requires knowing $f$, so it is inefficient in the framework
  present in this chapter; however, we are addressing this issue.\pg{Update}
\item The result is an inefficient nil change, because we do not
  use a computed derivative but simply
  $\NilC{f} = \Diff{f}{f} = \Lam{x}{\Lam{dx}{\Diff{\App{f}{\Update
          x {\D{x}}}}{\App{f}{x}}}}$. One can imagine a few ways
  to avoid that, but some require nontrivial changes to the
  framework. For instance, one could add derivatives as an
  additional observation of basic functions, so that whenever we
  have access to a function we also have access to its
  derivative. We leave investigation on this point for future
  work.
\item The semantics of a pair or of its two elements together
  should arguably be equivalent by general reasons --- simply
  because the environment is itself a sort of product (that's for
  instance guaranteed by categorical semantics). This suggests
  that, if we allow omitting changes for components of products,
  we should also allow omitting them for entries in the context.
\item It is currently sometimes hard to detect whether a change
  is nil or not. We should arguably add a suitable method to
  change structures (which is specified to give a conservative
  answer), and implement it for function changes through yet
  another observation.
\end{itemize}

\subsection{Change structure for sum types}

\subsection{Summing change structures}
Given two change structures on type $A$, we can create a
\emph{sum change structure}, such that a change is either from
one branch or the other.

A derivative consuming such changes must be able to handle both
alternatives. In particular, the derivative of a primitive
consuming such changes needs to switch between a derivative
handling one change structure, and a derivative handling the
other change structure.% XXX clumsy.
