% Emacs, this is -*- latex -*-!
\section{Incremental Computation}
\label{sec:informal}

Incremental computation can improve the performance of programs
by avoiding to recompute a program's whole result if only part of
the program's input changes. In this section, we introduce
application scenarios of incremental computation by example. In
each case, we discuss how to achieve incremental computation
by changing the program to explicitly compute with changes of
data. These examples for \emph{manual} program transformation
serve as an informal specification of what we want to achieve
with an \emph{automatic} program transformation. The final
example will also show that in a language with first-class
functions, where we have to consider changes of functions in addition
to changes of data.

We first incrementalize by hand the function $f_1 =
\Lam{x}{\Add{x}{1}}$. Its incremental version, or
\emph{derivative}, is $f_1' = \Lam{x}{\Lam{\D x}{\D x}}$: The function
$f_1'$ computes the change to the output given an input and its
change. More precisely, $f_1'$ satisfies the following correctness
property:
\[
\App{f_1}{\Add*{x}{\D x}} = \Add{\App{f_1}{x}}{\App{\App{f_1'}{x}}{\D x}}
\]
Moreover, when $\App{f_1}{x}$ is already computed, already on this
small example it takes less steps to compute the right-hand side
$\Add{\App{f_1}{x}}{\App{\App{f_1'}{x}}{\D x}}$ than the left-hand side
$\App{f_1}{\Add*{x}{\D x}}$. That is, using incremental computation
already improves performance.

We can make a similar example using multisets, or \emph{bags}.
Bags are unordered collections; unlike in sets, an element can
appear multiple times.
%
For simplicity, we restrict
our attention to bags of integers.
%
We can incrementalize by hand the function
$f_2 = \Lam{x}{\Merge{x}{\BagLit{1, 2}}}$:
%
this function takes a bag as argument and computes its merge with
the bag $\BagLit{1, 2}$, containing only
$1$ and $2$. Its derivative is $f_2' = \Lam{x}{\Lam{\D x}{\D x}}$: once
again, $f_2'$ computes the change to the output given an input and
its change (expressed as a bag). More precisely, since $\MERGE$
is commutative, $f_2'$ satisfies the following correctness
property:
\[
\App{f_2}{\Merge*{x}{\D x}} = \Merge{\App{f_2}{x}}{\App{\App{f_2'}{x}}{\D x}}
\]
Moreover, as before, when $\App{f_2}{x}$ is already computed, it
takes less steps to compute the right-hand side
$\Merge{\App{f_2}{x}}{\App{\App{f_2'}{x}}{\D x}}$\pg{Spacing looks
  wrong here} than to compute the left-hand side
$\App{f_2}{\Merge*{x}{\D x}}$. Hence, also here using incremental
computation improves performance.

When changes to bags are represented as bags, it is easy to
represent the inclusion of new elements into a bag $x$: one can
simply use a bag $\D x$ collecting those new elements, and
$\Merge{x}{\D x}$ will represent the updated bag. An element can
also be added multiple times, and it will then be present in $\D x$
with a multiplicity higher than $1$. For instance, $theAnswerAgain =
\BagLit{42,42}$ is a bag where $42$
appears with multiplicity $2$, and represents the change which
adds $42$ twice to a bag.

To allow also removing elements, we allow elements to appear in a
bag with \emph{negative multiplicities} (following
\citet{Koch10IQE}). $\NEGATE$ allows negating the multiplicities
of elements in a bag; hence, $\Negate{theAnswerAgain}$ is a bag
containing $42$ with multiplicity $-2$, and representing the
change which removes $42$ twice to a bag.

Our examples are also similar because both integers and bags are
\emph{commutative groups}.\pg{resume}

\pg{Example: $f = \Lam{x}{\Lam{y}{x + y}}$. Then,
  one could try to use this to describe changes on
  $\Lam{y}{x + y}$, and then use this on \texttt{bag1 flatMap (x
    => bag2 map (y => x + y)}. Or, without flatMap,
  \texttt{bag1 map (x => bag2 map (y => x + y) sum}.}

\ko{It would be better to use the terminology and notation from the intro here,
e.g., talk about what is the derivative of what, what is the meaning of $\Diff*yx$ in the
example, etc.}

\pg{Cai suggests: show one example with a standard fold, and then
  change it to use foldBag, to show the adaptations the user
  needs to do.}
